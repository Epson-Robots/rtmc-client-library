//Original Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//Modifications Copyright 2025 Seiko Epson Corporation
//This file is a modified version of DDSCommunicationPublisher.cpp and DDSCommunicationSubscriber.cpp, which were originally generated by fastddsgen.
//Applied a namespace to the DDSCommunication class and added new function

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file DDSCommunicationPublisher.cpp
 * This file contains the implementation of the publisher functions.
 *
 * This file was generated by the tool fastddsgen.
 */

 /*!
 * @file DDSCommunicationSubscriber.cpp
 * This file contains the implementation of the subscriber functions.
 *
 * This file was generated by the tool fastddsgen.
 */


#include "rtmc/DDSCommunication.h"
#include "rtmc/DDSCommunicationPubSubTypes.h"
#include "rtmc/rtmc_log.h"

#include <fastdds/dds/publisher/Publisher.hpp>
#include <fastdds/dds/publisher/qos/PublisherQos.hpp>
#include <fastdds/dds/publisher/DataWriter.hpp>
#include <fastdds/dds/publisher/qos/DataWriterQos.hpp>

#include <thread>
#include <chrono>
#include <iostream>

using namespace std;

using namespace eprosima::fastdds::dds;

namespace epson_rtmc_client
{

    DDSCommunication::DDSCommunication()
        : participant_(nullptr)
        , publisher_(nullptr)
        , subscriber_(nullptr)
        , topic_(nullptr)
        , writer_(nullptr)
        , reader_(nullptr)
        , type_(new RRDStuructPubSubType())
    {
    }

    DDSCommunication::~DDSCommunication()
    {
        if (writer_ != nullptr)
        {
            publisher_->delete_datawriter(writer_);
        }
        if (reader_ != nullptr)
        {
            subscriber_->delete_datareader(reader_);
        }
        if (publisher_ != nullptr)
        {
            participant_->delete_publisher(publisher_);
        }
        if (subscriber_ != nullptr)
        {
            participant_->delete_subscriber(subscriber_);
        }
        if (topic_ != nullptr)
        {
            participant_->delete_topic(topic_);
        }
        DomainParticipantFactory::get_instance()->delete_participant(participant_);
    }

    bool DDSCommunication::init(const COMPROPERTY& com_property, bool com_property_option_flag, const COMPROPERTYOPT& com_property_option, const SECPROPERTY& sec_property)
    {
        DomainParticipantQos pqos=PARTICIPANT_QOS_DEFAULT;

        Config_ParticipantQoS(&pqos,com_property,com_property_option_flag,com_property_option,sec_property);

        pqos.name("Participant_pub");
        participant_ = DomainParticipantFactory::get_instance()->create_participant(0, pqos);
        if (participant_ == nullptr)
        {
            RTMCLOG_ERR("Failed to initialize communication due to security file error");
            return false;
        }

        type_.register_type(participant_);

        PublisherQos pbqos=PUBLISHER_QOS_DEFAULT;
        SubscriberQos sbqos=SUBSCRIBER_QOS_DEFAULT;

        Config_PubSubQoS(&pbqos,&sbqos);

        publisher_ = participant_->create_publisher(pbqos, nullptr);
        if (publisher_ == nullptr)
        {
            RTMCLOG_ERR("Failed to initialize communication due to publiser creation failure");
            return false;
        }

        subscriber_ = participant_->create_subscriber(sbqos, nullptr);
        if (subscriber_ == nullptr)
        {
            RTMCLOG_ERR("Failed to initialize communication due to subscriber creation failure");
            return false;
        }

        topic_ = participant_->create_topic(
            "DDSCommunicationTopic",
            type_.get_type_name(),
            TOPIC_QOS_DEFAULT);
        if (topic_ == nullptr)
        {
            RTMCLOG_ERR("Failed to initialize communication due to topic creation failure");
            return false;
        }

        DataWriterQos wqos = DATAWRITER_QOS_DEFAULT;
        DataReaderQos rqos = DATAREADER_QOS_DEFAULT;

        Config_WriteReadQoS(&wqos,&rqos);

        writer_ = publisher_->create_datawriter(topic_, wqos, &publistener_);
        if (writer_ == nullptr)
        {
            RTMCLOG_ERR("Failed to initialize communication due to datawriter creation failure"); 
            return false;
        }

        rqos.reliability().kind = RELIABLE_RELIABILITY_QOS;
        reader_ = subscriber_->create_datareader(topic_, rqos, &sublistener_);
        if (reader_ == nullptr)
        {
            RTMCLOG_ERR("Failed to initialize communication due to datareader creation failure");
            return false;
        }

        publistener_.init(&cv_connect,&mutex_connect);
        sublistener_.init(&cv_connect,&mutex_connect);
        
        return true;
    }

    void DDSCommunication::Config_ParticipantQoS(eprosima::fastdds::dds::DomainParticipantQos* ppqos,COMPROPERTY com_property,  bool com_property_option_flag,COMPROPERTYOPT com_property_option,SECPROPERTY sec_property)
    {
        WireProtocolConfigQos wire_protocol_qos;
        
        if(com_property_option_flag){
            eprosima::fastrtps::rtps::Locator_t client_locator_builtin;
            eprosima::fastrtps::rtps::IPLocator::setIPv4(client_locator_builtin,com_property_option.client_ip_address);
            client_locator_builtin.port=com_property_option.client_builtinmsg_port;
            wire_protocol_qos.builtin.metatrafficUnicastLocatorList.push_back(client_locator_builtin);

            eprosima::fastrtps::rtps::Locator_t client_locator_userdata;
            eprosima::fastrtps::rtps::IPLocator::setIPv4(client_locator_userdata,com_property_option.client_ip_address);
            client_locator_userdata.port=com_property_option.client_userdata_port;
            wire_protocol_qos.default_unicast_locator_list.push_back(client_locator_userdata);
        }
        
        ppqos->wire_protocol(wire_protocol_qos);

        eprosima::fastrtps::rtps::Locator_t initial_peer;
        eprosima::fastrtps::rtps::IPLocator::setIPv4(initial_peer,com_property.rc_ip_address);
        initial_peer.port=com_property. rc_builtinmsg_port;
        ppqos->wire_protocol().builtin.initialPeersList.push_back(initial_peer);

        ppqos->wire_protocol().builtin.discovery_config.leaseDuration={1,0};
        ppqos->wire_protocol().builtin.discovery_config.leaseDuration_announcementperiod={0,500000000};

        if(sec_property.security_communication_flag)
        {

            ppqos->properties().properties().emplace_back("dds.sec.auth.plugin","builtin.PKI-DH");
        
            ppqos->properties().properties().emplace_back("dds.sec.auth.builtin.PKI-DH.identity_ca","file://"+sec_property.ca_cert_filepath);
        
            ppqos->properties().properties().emplace_back("dds.sec.auth.builtin.PKI-DH.identity_certificate", "file://"+sec_property.client_cert_filepath);
        
            ppqos->properties().properties().emplace_back("dds.sec.auth.builtin.PKI-DH.private_key", "file://"+sec_property.client_private_key);
        
            ppqos->properties().properties().emplace_back("dds.sec.access.plugin","builtin.Access-Permissions");
        
            ppqos->properties().properties().emplace_back("dds.sec.access.builtin.Access-Permissions.permissions_ca","file://"+sec_property.ca_cert_filepath);
            ppqos->properties().properties().emplace_back("dds.sec.access.builtin.Access-Permissions.governance", "file://"+sec_property.client_governance_filepath);
            ppqos->properties().properties().emplace_back("dds.sec.access.builtin.Access-Permissions.permissions","file://"+sec_property.client_permissions_filepath);
            ppqos->properties().properties().emplace_back("dds.sec.crypto.plugin","builtin.AES-GCM-GMAC");
        }

    }

    void DDSCommunication::Config_PubSubQoS(eprosima::fastdds::dds::PublisherQos* ppbqos,eprosima::fastdds::dds::SubscriberQos* psbqos)
    {
    ppbqos->partition().push_back("RTMC_CMD");

    psbqos->partition().push_back("RTMC_RES");

    }

    void DDSCommunication::Config_WriteReadQoS(eprosima::fastdds::dds::DataWriterQos* pwqos,eprosima::fastdds::dds::DataReaderQos* prqos)
    {
    RTPSReliableWriterQos rtps_rlbw_qos;
    DataSharingQosPolicy  ds_qos_w;
    rtps_rlbw_qos.disable_positive_acks.enabled=true;
    rtps_rlbw_qos.times.heartbeatPeriod={0,1000000};
    rtps_rlbw_qos.times.nackResponseDelay={0,1000000};
    ds_qos_w.off();

    pwqos->reliability().kind=RELIABLE_RELIABILITY_QOS;
    pwqos->reliable_writer_qos(rtps_rlbw_qos);
    pwqos->data_sharing(ds_qos_w);

    RTPSReliableReaderQos rtps_rlbr_qos;
    DataSharingQosPolicy  ds_qos_r;
    rtps_rlbr_qos.disable_positive_ACKs.enabled=true;
    rtps_rlbr_qos.times.heartbeatResponseDelay={0,1000000};
    ds_qos_r.off();

    prqos->reliability().kind=RELIABLE_RELIABILITY_QOS;
    prqos->reliable_reader_qos(rtps_rlbr_qos);
    prqos->data_sharing(ds_qos_r);
        
    }


    int DDSCommunication::DDS_Send(RRD rrddata_cmd,RRD* prrddata_res)
    {
    
        sublistener_.Lock();
        // Publication code

        RRDSturuct RRDst;
        bool res=false;
        struct timespec timeout;
        int ret=0;

        RRDst.commandID(rrddata_cmd.commandid);
        RRDst.dwordParam(rrddata_cmd.dwordparam);
        RRDst.exData(rrddata_cmd.exData);

        res=writer_->write(&RRDst);
        if(!res) {
            RTMCLOG_ERR("Failed to send the command");
            sublistener_.UnLock();
            return UNDEFINED_ERR;
        }

        clock_gettime(CLOCK_REALTIME,&timeout);
        timeout.tv_sec += 5;

        ret=sublistener_.TimedWait(timeout);
        if(ret!=0){
            if(ret==ETIMEDOUT){
                RTMCLOG_ERR("Failed to receive a response from the controller within the time limit");
                sublistener_.UnLock();
                return TIMEOUT_ERR;

            }else{
                RTMCLOG_ERR("Failed to wait for a response from the controller");
                sublistener_.UnLock();
                return UNDEFINED_ERR;

            }
        }

        if(sublistener_.CanGetRRDData()){

            res=sublistener_.get_RRDData(rrddata_cmd.commandid,prrddata_res);
            if(!res) {
                sublistener_.UnLock();
                return UNDEFINED_ERR;
            }

            res=Check_cmdID(rrddata_cmd.commandid,prrddata_res->commandid);
            if(!res)
            {
                RTMCLOG_ERR("The command ID of the request does not match the command ID of the responose");
                sublistener_.UnLock();
                return UNDEFINED_ERR;
            }
        }else{
            sublistener_.UnLock();
            return UNDEFINED_ERR;
        }

        sublistener_.UnLock();

        return SEND_SUCCESS;
    }


    bool DDSCommunication::DDSConnection()
    {
        if((publistener_.publisher_connection() && sublistener_.subscriber_connection())) return true;
        
        return false;
    }


    bool DDSCommunication::Get_NewStatus(unsigned short cmdID, RRD* prrddata_new, bool* update)
    {
        
        if((cmdID == SYS_NOTICE_RC_STATUS) || (cmdID == SYS_NOTICE_CURPOS))
        {
            if(sublistener_.CanGetRRDData()){

                bool ret=sublistener_.get_RRDData(cmdID,prrddata_new,update); 
                if(!ret) return false;
                ret=Check_cmdID(cmdID,prrddata_new->commandid);
                if(!ret) return false;
        
                return ret;
                
            }
        }

        return false;
    }



    bool DDSCommunication::MakeRRDdata(unsigned short cmdid, unsigned int dwparam, const vector<uint8_t>& exdata, RRD& prrd_cmd)
    {
        if((cmdid < SYS_REQ_CMDID_MIN)                            ||
        ((cmdid > SYS_REQ_CMDID_MAX) && (cmdid < REQ_CMDID_MIN)) ||
        (cmdid > REQ_CMDID_MAX)
        ) return false;

        prrd_cmd.commandid=cmdid;
        prrd_cmd.dwordparam=dwparam;
        prrd_cmd.exData=exdata;
        
        return true;
    
    }

    bool DDSCommunication::Check_exDataSize(const unsigned short& cmdID, const unsigned short& low_word, const RRDCoreData& rrd_res_core) const
    {
        unsigned short correct_data_size = 0;
        switch (cmdID) {
            case SYS_REQ_RC_STATUS:        correct_data_size = 32; break;
            case SYS_REQ_CURPOS_INFO:      correct_data_size = 48; break;
            case SYS_REQ_RTMC_FORMAT_INFO: correct_data_size = 2;  break;
            case REQ_EXEC_RTPOS:           correct_data_size = 64; break;
            case REQ_GET_CURPOS_INFO:      correct_data_size = 48; break;
            case REQ_GET_DO:               correct_data_size = 2;  break;
            case REQ_GET_DI:               correct_data_size = 2;  break;
            case REQ_GET_WEIGHT:           correct_data_size = 8;  break;
            case REQ_GET_INERTIA:
                if (low_word == 0) 
                    correct_data_size = 8;
                else 
                    correct_data_size = 16;
                break;
            default: 
                return true;
                break;
        }

        if (rrd_res_core.exData.size() != correct_data_size) return false;

        return true;
    }

    bool DDSCommunication::wait_for_connect(unsigned int wait_time)
    {
        std::unique_lock<std::mutex> lock(mutex_connect);
        if (!cv_connect.wait_for(lock, std::chrono::milliseconds(wait_time), [this] {return DDSConnection();}))
            return false;

        return true;
    }

    void DDSCommunication::PubListener::init(std::condition_variable * cv_connect, std::mutex* pmutex_connect) 
    {
        cv_connect_ptr = cv_connect;
        mutex_connect_ptr=pmutex_connect;
    }

    void DDSCommunication::PubListener::on_publication_matched(
        eprosima::fastdds::dds::DataWriter*,
        const eprosima::fastdds::dds::PublicationMatchedStatus& info)
    {
        if (info.current_count_change == 1)
        {
            {
                std::lock_guard<std::mutex> lock(*mutex_connect_ptr);
                matched = true;
            }
            cv_connect_ptr->notify_one();
        }
        else if (info.current_count_change == -1)
        {
            disconnect=true;
            matched = false;
        }
        else
        {               
            disconnect=true;
            matched = false;
            RTMCLOG_ERR("Failed to match with the subscriber due to an undefined error");
        }

    }

    bool DDSCommunication::PubListener::publisher_connection()
    {
        if((!disconnect) && (matched)) {
            return true;
        }

        return false;
    }


    void DDSCommunication::SubListener::init(std::condition_variable *cv_connect, std::mutex* pmutex_connect)
    {
        rrddata_cmdres.commandid=0;
        rrddata_cmdres.dwordparam=0;
        rrddata_rc_status.commandid=SYS_NOTICE_RC_STATUS;
        rrddata_rc_status.dwordparam=0;
        rrddata_ja_status.commandid=SYS_NOTICE_CURPOS;
        rrddata_ja_status.dwordparam=0;
        pthread_mutex_init(&mutex_sig_,NULL);
        pthread_cond_init(&sig_condition,NULL);
        cv_connect_ptr = cv_connect;
        mutex_connect_ptr = pmutex_connect;
    }

    void DDSCommunication::SubListener::on_subscription_matched(
        DataReader*,
        const SubscriptionMatchedStatus& info)
    {
        if (info.current_count_change == 1)
        {
            {
                std::lock_guard<std::mutex> lock(*mutex_connect_ptr);
                matched = true;
            }
            cv_connect_ptr->notify_one();
        }
        else if (info.current_count_change == -1)
        {
            disconnect=true;
            matched = false;
        }
        else
        {
            disconnect=true;
            matched = false;
            RTMCLOG_ERR("Failed to match with the publisher due to an undefined error");
        }
    }

    void DDSCommunication::SubListener::on_data_available(
        DataReader* reader)
    {

        // Take data
        RRDSturuct RRDst;
        SampleInfo info;

        if (reader->take_next_sample(&RRDst, &info) == ReturnCode_t::RETCODE_OK)
        {
            if (info.valid_data)
            {
                unsigned short temp_cmdID=RRDst.commandID();

                if(temp_cmdID==SYS_NOTICE_RC_STATUS)
                {
                    mutex_rrd_.lock();
                    
                    rrddata_rc_status.commandid=RRDst.commandID();
                    rrddata_rc_status.dwordparam=RRDst.dwordParam();
                    rrddata_rc_status.exData=RRDst.exData();
                    newRCstatus=true;
                    
                    mutex_rrd_.unlock();

                }else if(temp_cmdID==SYS_NOTICE_CURPOS)
                {
                    mutex_rrd_.lock();
                    
                    rrddata_ja_status.commandid=RRDst.commandID();
                    rrddata_ja_status.dwordparam=RRDst.dwordParam();
                    rrddata_ja_status.exData=RRDst.exData();
                    newJAstatus=true;
                    mutex_rrd_.unlock();

                }
                else
                {

                    Lock();

                    rrddata_cmdres.commandid=RRDst.commandID();
                    rrddata_cmdres.dwordparam=RRDst.dwordParam();
                    rrddata_cmdres.exData=RRDst.exData();

                    pthread_cond_signal(&sig_condition);
                    UnLock();
                }

            }
        
        }else{
            RTMCLOG_ERR("Failed to retrieve received data due to an undefined error");
            FailedGetRRDData=true;
        }


    }

    bool DDSCommunication::SubListener::get_RRDData(unsigned short cmdid, RRD* prrddata, bool* pupdate)
    {
        if(cmdid <= SYS_NOTICE_CMDID_MAX){

            if(cmdid==SYS_NOTICE_RC_STATUS)
            {
                mutex_rrd_.lock();            
                if(pupdate==nullptr) return false;
                *pupdate=newRCstatus;
                prrddata->commandid=rrddata_rc_status.commandid;
                prrddata->dwordparam=rrddata_rc_status.dwordparam;
                prrddata->exData=rrddata_rc_status.exData;
                newRCstatus=false;
                mutex_rrd_.unlock();

            }else if(cmdid==SYS_NOTICE_CURPOS)
            {
                if(pupdate==nullptr) return false;
                mutex_rrd_.lock();
                *pupdate=newJAstatus;
                prrddata->commandid=rrddata_ja_status.commandid;
                prrddata->dwordparam=rrddata_ja_status.dwordparam;
                prrddata->exData=rrddata_ja_status.exData;
                newJAstatus=false;
                mutex_rrd_.unlock();
            }
            else{
                RTMCLOG_ERR("Failed to retrieve data from epson robot controller due to an undefined command ID");
                return false;
            }
        }else if((cmdid >= REQ_CMDID_MIN  && cmdid <= REQ_CMDID_MAX) || (cmdid >= SYS_REQ_CMDID_MIN  && cmdid <= SYS_REQ_CMDID_MAX) )
        {
            prrddata->commandid=rrddata_cmdres.commandid;
            prrddata->dwordparam=rrddata_cmdres.dwordparam;
            prrddata->exData=rrddata_cmdres.exData;

        }else{
            RTMCLOG_ERR("Failed to retrieve epson robot controller response due to an undefined command ID");
            return false;
        }

    return true;

    }

    int DDSCommunication::SubListener::TimedWait(timespec timeout)
    {
        return pthread_cond_timedwait(&sig_condition,&mutex_sig_,&timeout);
    }

    bool DDSCommunication::SubListener::subscriber_connection()
    {
        if((!disconnect) && (matched)) {
            return true;
        }

        return false;
    }

    bool DDSCommunication::Check_cmdID(unsigned short req_cmdid,unsigned short res_cmdid)
    {
        if(req_cmdid==res_cmdid) return true;
        return false;
    }
}

